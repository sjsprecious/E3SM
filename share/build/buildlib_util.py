
from CIME.utils import run_cmd, run_bld_cmd_ensure_logging
from CIME.build import get_standard_makefile_args
from pathlib import Path

###############################################################################
def get_macro_var(macro_dump, varname):
###############################################################################
    look_for = f"{varname} :="
    for line in macro_dump.splitlines():
        if line.startswith(look_for):
            return line.split(":=")[-1].strip()

    return ""

###############################################################################
def extract_from_macros(case, comp_name, extra_vars=()):
###############################################################################
    """
    Hacky way of getting stuff from Macros. We use the $case/Macros.make file,
    which gets generated by CIME case.build and run it with -p to print all the
    variables it sets. This is currently the best method we have to query macro
    settings outside of CMake. It handles the COMP_NAME conditionals correctly,
    allowing us to customize things for specific sharedlibs.
    """
    standard_vars = ["SFC", "SCC", "SCXX",
                     "MPIFC", "MPICC", "MPICXX",
                     "CMAKE_Fortran_FLAGS", "CMAKE_C_FLAGS", "CMAKE_CXX_FLAGS",
                     "CPPDEFS", "CMAKE_EXE_LINKER_FLAGS"]
    all_vars = standard_vars + list(extra_vars)

    make_args = get_standard_makefile_args(case, shared_lib=True)
    macro_dump = run_cmd(f"make -f Macros.make COMP_NAME={comp_name} {make_args} -p")[1]

    result = []
    for macro_var in all_vars:
        macro_val = get_macro_var(macro_dump, macro_var)
        result.append(macro_val)

    return result

###############################################################################
def config_if_not_configured(name, bldroot, cmd, log_obj, is_cmake=True):
###############################################################################
    check_file = Path(bldroot) / ("CMakeCache.txt" if is_cmake else "config.status")
    # Don't re-run config if it has already been called
    if not check_file.exists():
        log_obj.info(f"Configuring {name} in {bldroot}")
        run_bld_cmd_ensure_logging(cmd, log_obj, from_dir=bldroot)
    else:
        log_obj.info(f"{name} appears to have been configured already in {bldroot}, skipping CMake")
